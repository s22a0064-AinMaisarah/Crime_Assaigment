# -*- coding: utf-8 -*-
"""Uber_and_Urban_Crime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15V2hrRfXAwRt7_d1IDc-MpMc2opJhRhX
"""

import pandas as pd

# Read the CSV file into a DataFrame
df_uber = pd.read_csv('/content/uberdata_9_3.csv')

# Display the DataFrame
display(df_uber)

print("Missing values per column:")
print(df_uber.isnull().sum())

print("\nNumber of duplicate rows:")
print(df_uber.duplicated().sum())

import pandas as pd

# Drop entire rows that have NaN
df_uber_cleaned = df_uber.dropna()

# Set display options to show all columns and more rows
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

print("Cleaned DataFrame Head:")
display(df_uber_cleaned.head())

# Reset display options to default
pd.reset_option('display.max_columns')
pd.reset_option('display.max_rows')

print("\nShape of the DataFrame after dropping rows with missing values:")
print(df_uber_cleaned.shape)

print("Descriptive Statistics for Numerical Columns:")
display(df_uber_cleaned.describe())

print("\nValue Counts for Categorical Columns:")
for col in df_uber_cleaned.select_dtypes(include='object').columns:
    print(f"\nValue counts for column: {col}")
    display(df_uber_cleaned[col].value_counts())

print("Column Names:")
print(df_uber_cleaned.columns.tolist())

columns_to_drop = ['Unnamed: 0', 'inc_month', 'identifier', 'inc_year', 'date.NIBRS', 'date.uber', 'uber', 'treated_month', 'drovealone', 'carpool', 'public', 'skin_white', 'skin_black', 'nonlatino_white', 'commute_time', 'owner_occupied', 'rental', 'Vehicle_0', 'Vehicle_1', 'Vehicle_2', 'Vehicle_3_plus', 'pop', 'car_to_work', 'drovealone_dup', 'carpooled_dup', 'carpool_2', 'carpool_3', 'carpool_4_plus', 'workers_per_van', 'public_transit', 'walk', 'bike', 'cab_other', 'work_home', 'work_in_state_in_county', 'work_in_state_out_county', 'work_out_state', 'work_in_place', 'com_10_less', 'com_15', 'com_20', 'com_25', 'com_30', 'com_35', 'com_40', 'com_45_to_60', 'com_60_plus', 'married', 'widowed', 'divorced', 'seperated', 'never_married', 'land_area', 'water_area', 'city_name',  'treated', 'measure_change', 'density', 't', 't_sq', 'edu_highschool_up', 'water_proportion', 'against_persons', 'major_violent', 'other_violent', 'major_binary', 'id', 'ln_offense_count', 'ln_density', 'ln_pop', 'interact', 'cab_carpool_other', 'sin1', 'cos1', 'sin2', 'cos2', 'treat_month_x_cab_carpool_other', 'treat_month_x_public_transit', 'treat_month_x_walking', 'cumTreatedMonth', 'ln_against_persons', 'nonviolent', 'ln_nonviolent', 'irrelevant_crimes', 'relevant_crimes', 'ln_irrelevant', 'ln_relevant', 'lead', 'lag_Vehicle_0', 'lag_Vehicle_1', 'lag_Vehicle_2', 'lag_Vehicle_3_plus', 'lag_car_to_work', 'lag_drovealone', 'lag_carpool', 'lag_workers_per_van', 'lag_public_transit', 'lag_walk', 'lag_bike', 'lag_cab_other', 'lag_work_in_state_out_county', 'lag_work_out_state', 'lag_commute_time', 'lag_com_15', 'lag_com_20', 'lag_com_25', 'lag_com_30', 'lag_com_35', 'lag_com_40', 'lag_com_45_to_60', 'lag_com_60_plus']

# Filter columns_to_drop to only include columns that exist in the DataFrame
existing_columns_to_drop = [col for col in columns_to_drop if col in df_uber_cleaned.columns]

df_uber_cleaned = df_uber_cleaned.drop(columns=existing_columns_to_drop)

print("Shape of the DataFrame after dropping columns:")
print(df_uber_cleaned.shape)

print("\nDataFrame Head after dropping columns:")
display(df_uber_cleaned.head())

print("Column Names:")
print(df_uber_cleaned.columns.tolist())

import pandas as pd

# Map the categorical values to numerical values and replace the original column
mapping = {'Group II (Cities 100,000 - 249,999)': 0, 'Group I (Cities 250,000 and over)': 1}
df_uber_cleaned['city_cat'] = df_uber_cleaned['city_cat'].replace(mapping)

# Create crime grouping columns
# Violent crime score
df_uber_cleaned['violent_crime'] = (df_uber_cleaned['homicide'] + df_uber_cleaned['kidnapping'] + df_uber_cleaned['sex_forcible'] +
                       df_uber_cleaned['robbery'] + df_uber_cleaned['assault'] + df_uber_cleaned['weapon_violations'] +
                       df_uber_cleaned['human_traffic'])

# Property crime score
df_uber_cleaned['property_crime'] = (df_uber_cleaned['burglary_bne'] + df_uber_cleaned['larceny_theft'] +
                        df_uber_cleaned['motor_vehicle_theft'] + df_uber_cleaned['arson'] +
                        df_uber_cleaned['stolen_property'] + df_uber_cleaned['destruction_property'])

# White-collar crime score
df_uber_cleaned['whitecollar_crime'] = (df_uber_cleaned['counterfit_forge'] + df_uber_cleaned['fraud'] +
                           df_uber_cleaned['embezzelment'] + df_uber_cleaned['extortion_blackmail'])

# Social / moral crime score
df_uber_cleaned['social_crime'] = (df_uber_cleaned['drug_offenses'] + df_uber_cleaned['sex_nonforcible'] +
                      df_uber_cleaned['porn'] + df_uber_cleaned['prostitution'] + df_uber_cleaned['gambling'])


print("DataFrame Head after encoding 'city_cat' and creating crime grouping columns:")
display(df_uber_cleaned.head())

# Set display options to show all columns and more rows
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

print("Cleaned DataFrame:")
display(df_uber_cleaned)

# Reset display options to default
pd.reset_option('display.max_columns')
pd.reset_option('display.max_rows')

columns_to_drop_crimes = [
    'homicide', 'kidnapping', 'sex_forcible', 'robbery', 'assault', 'arson',
    'extortion_blackmail', 'burglary_bne', 'larceny_theft', 'motor_vehicle_theft',
    'counterfit_forge', 'fraud', 'embezzelment', 'stolen_property', 'destruction_property',
    'drug_offenses', 'sex_nonforcible', 'porn', 'gambling', 'prostitution', 'bribery',
    'weapon_violations', 'human_traffic', 'city_cat_encoded',
    'homicide_log', 'kidnapping_log', 'sex_forcible_log', 'robbery_log', 'assault_log',
    'arson_log', 'extortion_blackmail_log', 'burglary_bne_log', 'larceny_theft_log',
    'motor_vehicle_theft_log', 'counterfit_forge_log', 'fraud_log', 'embezzelment_log',
    'stolen_property_log', 'destruction_property_log', 'drug_offenses_log',
    'sex_nonforcible_log', 'porn_log', 'gambling_log', 'prostitution_log', 'bribery_log',
    'weapon_violations_log', 'human_traffic_log', 'offense_count_log',
    'age_log', 'male_log', 'poverty_log', 'high_school_below_log'
]

# Filter columns_to_drop to only include columns that exist in the DataFrame
existing_columns_to_drop_crimes = [col for col in columns_to_drop_crimes if col in df_uber_cleaned.columns]

df_uber_cleaned = df_uber_cleaned.drop(columns=existing_columns_to_drop_crimes)

print("Shape of the DataFrame after dropping crime columns:")
print(df_uber_cleaned.shape)

print("\nDataFrame Head after dropping crime columns:")
display(df_uber_cleaned.head())

import matplotlib.pyplot as plt
import seaborn as sns

# Visualize the distribution of the new crime scores
crime_score_cols = ['violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime']

plt.figure(figsize=(15, 10))
for i, col in enumerate(crime_score_cols):
    plt.subplot(2, 2, i + 1)
    sns.histplot(df_uber_cleaned[col], kde=True)
    plt.title(f'Distribution of {col}')
plt.tight_layout()
plt.show()

# Visualize the relationship between crime scores and city category
plt.figure(figsize=(15, 10))
for i, col in enumerate(crime_score_cols):
    plt.subplot(2, 2, i + 1)
    sns.boxplot(x='city_cat', y=col, data=df_uber_cleaned)
    plt.title(f'{col} by City Category')
    plt.xlabel('City Category (0: Group II, 1: Group I)')
    plt.ylabel(col)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Calculate the correlation matrix for numerical columns
numerical_cols = df_uber_cleaned.select_dtypes(include=['int64', 'float64']).columns
correlation_matrix = df_uber_cleaned[numerical_cols].corr()

# Create a heatmap with annotations
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Heatmap of Numerical Columns')
plt.show()

import plotly.express as px

# Interactive Box Plot: Offense Count by City Category with hover information
fig_offense_citycat = px.box(
    df_uber_cleaned,
    x='city_cat',
    y='offense_count',
    color='city_cat',
    hover_data=['city_cat', 'offense_count', 'violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime', 'state', 'age', 'income', 'poverty'],
    title='Interactive Box Plot: Offense Count by City Category',
    labels={'city_cat': 'City Category (0: Group II, 1: Group I)'}
)
fig_offense_citycat.show()

import plotly.express as px

# Interactive Scatter Plot: Income vs. City Category with hover information
fig_income_citycat = px.scatter(
    df_uber_cleaned,
    x='income',
    y='city_cat',
    color='city_cat',
    hover_data=['city_cat', 'income', 'offense_count', 'violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime'],
    title='Interactive Scatter Plot: Income vs. City Category',
    labels={'city_cat': 'City Category (0: Group II, 1: Group I)'}
)
fig_income_citycat.show()

# Interactive Scatter Plot: Poverty % vs. City Category with hover information
fig_poverty_citycat = px.scatter(
    df_uber_cleaned,
    x='poverty',
    y='city_cat',
    color='city_cat',
    hover_data=['city_cat', 'poverty', 'offense_count', 'violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime'],
    title='Interactive Scatter Plot: Poverty % vs. City Category',
    labels={'city_cat': 'City Category (0: Group II, 1: Group I)'}
)
fig_poverty_citycat.show()



import plotly.express as px

# Interactive Scatter Plot: Income vs. Offense Count with hover information and City Category color
fig_income_offense = px.scatter(
    df_uber_cleaned,
    x='income',
    y='offense_count',
    color='city_cat',
    hover_data=['city_cat', 'income', 'offense_count', 'violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime', 'state', 'age'],
    title='Interactive Scatter Plot: Income vs. Offense Count by City Category',
    labels={'city_cat': 'City Category (0: Group II, 1: Group I)'},
    trendline='ols' # Add OLS trendline
)
fig_income_offense.show()

# Interactive Scatter Plot: Poverty % vs. Offense Count with hover information and City Category color
fig_poverty_offense = px.scatter(
    df_uber_cleaned,
    x='poverty',
    y='offense_count',
    color='city_cat',
    hover_data=['city_cat', 'poverty', 'offense_count', 'violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime', 'state', 'age'],
    title='Interactive Scatter Plot: Poverty % vs. Offense Count by City Category',
    labels={'city_cat': 'City Category (0: Group II, 1: Group I)'},
    trendline='ols' # Add OLS trendline
)
fig_poverty_offense.show()



"""### Interpretation/Discussion: Crime Clusters

Based on the K-Means clustering and PCA visualization, we identified three distinct crime pattern clusters:

*   **Cluster 0:** This cluster generally represents cities with **moderate crime levels** across the four crime types (violent, property, white-collar, and social). The average crime scores for these categories are in the mid-range compared to the other clusters.
*   **Cluster 1:** This cluster appears to represent cities with **high crime levels** across most categories, particularly violent and property crimes, and the highest average white-collar crime. These cities might face broader challenges related to crime.
*   **Cluster 2:** This cluster seems to encompass cities with **lower crime levels** across all crime types. The average crime scores for this cluster are consistently the lowest.

The PCA visualization helps to separate these clusters in a 2-dimensional space based on the crime scores, visually confirming the distinctions found by the clustering algorithm.

Further analysis is needed to explore the demographic and economic characteristics of the cities within each cluster to gain a deeper understanding of the factors associated with these different crime patterns.
"""

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

# Select crime-related columns
features = ['violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime']
X = df_uber_cleaned[features]

# Scale the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Determine optimal number of clusters using the Elbow Method
wcss = []  # within-cluster-sum-of-squares
for k in range(2, 10):
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10) # Added n_init
    kmeans.fit(X_scaled)
    wcss.append(kmeans.inertia_)

# Plot the Elbow Method
plt.figure(figsize=(8,6))
plt.plot(range(2, 10), wcss, marker='o')
plt.title('Elbow Method for Optimal k')
plt.xlabel('Number of Clusters')
plt.ylabel('WCSS')
plt.show()

# Apply K-Means clustering (Choosing k=3 based on visual inspection of the elbow plot)
kmeans = KMeans(n_clusters=3, random_state=42, n_init=10) # Added n_init
df_uber_cleaned['crime_cluster'] = kmeans.fit_predict(X_scaled)

# Perform PCA for visualization
pca = PCA(n_components=2)
pca_data = pca.fit_transform(X_scaled)

df_uber_cleaned['PC1'] = pca_data[:, 0]
df_uber_cleaned['PC2'] = pca_data[:, 1]

# Visualize the clusters using PCA with Plotly Express for interactivity
fig_clusters = px.scatter(
    df_uber_cleaned,
    x='PC1',
    y='PC2',
    color='crime_cluster',
    hover_data=['crime_cluster', 'violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime', 'city_cat', 'state', 'age', 'income', 'poverty'],
    title='Crime Pattern Clusters (PCA)',
    labels={'crime_cluster': 'Crime Cluster'}
)
fig_clusters.show()


# Analyze cluster profiles
cluster_profile = df_uber_cleaned.groupby('crime_cluster')[features].mean().reset_index()
cluster_profile_melted = cluster_profile.melt(id_vars='crime_cluster', var_name='Crime Type', value_name='Average Crime Score')

# Visualize cluster profiles interactively using Plotly Express
fig_cluster_profile = px.bar(
    cluster_profile_melted,
    x='Crime Type',
    y='Average Crime Score',
    color='crime_cluster',
    barmode='group',
    hover_data=['crime_cluster', 'Crime Type', 'Average Crime Score'],
    title='Interactive Bar Chart: Average Crime Scores per Cluster',
    labels={'crime_cluster': 'Crime Cluster'}
)
fig_cluster_profile.show()



"""Based on the cluster profiles, we can interpret the crime clusters as follows:

*   **Cluster 0:** Cities in this cluster tend to have **moderate levels** of violent and property crimes, and **higher levels** of white-collar and social crimes compared to Cluster 2, but lower than Cluster 1.
*   **Cluster 1:** Cities in this cluster tend to have the **highest levels** of violent, property, and white-collar crimes. They also have relatively high social crime scores. This could represent cities with **high overall crime rates across multiple categories**.
*   **Cluster 2:** Cities in this cluster tend to have the **lowest levels** of violent, property, white-collar, and social crimes. This cluster likely represents cities with **generally lower crime rates**.

This interpretation is based on the average crime scores within each cluster. We can further investigate the characteristics of the cities belonging to each cluster to gain more insights.
"""

print("Unique values in the 'age' column:")
print(df_uber_cleaned['age'].unique())

df_uber_cleaned['age_group'] = pd.cut(
    df_uber_cleaned['age'],
    bins=[30, 35, 38, 41, 50],
    labels=['30-35', '35-38', '38-41', '41+'],
    right=False # Use right=False to include the left bin edge
)

# map categorical age groups to numbers
age_group_mapping = {
    '30-35': 0,
    '35-38': 1,
    '38-41': 2,
    '41+': 3
}

df_uber_cleaned['age_group_num'] = df_uber_cleaned['age_group'].map(age_group_mapping)

print("First 50 rows with numeric age groups:")
display(df_uber_cleaned[['age', 'age_group', 'age_group_num']].head(50))

# Set display options to show all columns and more rows
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

print("Cleaned DataFrame:")
display(df_uber_cleaned)

# Reset display options to default
pd.reset_option('display.max_columns')
pd.reset_option('display.max_rows')

columns_to_drop_after_clustering = ['age', 'age_group', 'gender_category', 'crime_cluster', 'PC1', 'PC2']

# Filter columns to drop that exist in the DataFrame
existing_columns_to_drop = [col for col in columns_to_drop_after_clustering if col in df_uber_cleaned.columns]

# Drop the columns
df_uber_cleaned = df_uber_cleaned.drop(columns=existing_columns_to_drop)

# Rename 'age_group_num' to 'age' if 'age_group_num' exists
if 'age_group_num' in df_uber_cleaned.columns:
    df_uber_cleaned = df_uber_cleaned.rename(columns={'age_group_num': 'age'})

print("DataFrame Head after dropping and renaming columns:")
display(df_uber_cleaned.head())

print("\nShape of the DataFrame after dropping and renaming columns:")
print(df_uber_cleaned.shape)

import plotly.express as px

# Define the crime score columns
crime_cols = ['violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime']

# Create interactive scatter plots for 'male' vs each crime score
for crime_type in crime_cols:
    fig = px.scatter(
        df_uber_cleaned,
        x='male',
        y=crime_type,
        hover_data=['city_cat', 'male', crime_type, 'age', 'income', 'poverty', 'state'],
        title=f'Interactive Scatter Plot: Male Population Percentage vs. {crime_type}',
        labels={'male': 'Male Population Percentage (%)', crime_type: crime_type.replace("_", " ").title()}
    )
    fig.show()

import plotly.express as px
import pandas as pd

# Define the crime score columns
crime_cols = ['violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime']

# Categorize cities based on male population percentage (you can adjust the bins)
# Let's use quartiles for simplicity
df_uber_cleaned['male_category'] = pd.qcut(df_uber_cleaned['male'], q=3, labels=['Low-Male', 'Balanced-Gender', 'High-Male'])

# Calculate the average crime scores per male category
male_category_crime_means = df_uber_cleaned.groupby('male_category', observed=True)[crime_cols].mean().reset_index()

# Melt the DataFrame for Plotly Express
crime_scores_melted_gender = male_category_crime_means.melt(
    id_vars='male_category',
    var_name='Crime Type',
    value_name='Average Crime Score'
)

# Create an interactive grouped bar chart
fig_gender_crime = px.bar(
    crime_scores_melted_gender,
    x='Crime Type',
    y='Average Crime Score',
    color='male_category',
    barmode='group',
    hover_data=['male_category', 'Crime Type', 'Average Crime Score'],
    title='Interactive Bar Chart: Average Crime Scores by Male Population Percentage Category',
    labels={'male_category': 'Male Population Category'}
)
fig_gender_crime.show()

import plotly.graph_objects as go
import pandas as pd

# Define the crime score columns
crime_cols = ['violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime']

# Calculate the average crime scores per age group
age_group_crime_means = df_uber_cleaned.groupby('age', observed=True)[crime_cols].mean().reset_index()

# Create a list of crime types for the theta axis
categories = crime_cols

# Create the figure
fig = go.Figure()

# Add a trace for each age group
for index, row in age_group_crime_means.iterrows():
    fig.add_trace(go.Scatterpolar(
        r=row[crime_cols].tolist(),
        theta=categories,
        fill='toself',
        name=f'Age Group {row["age"]}'
    ))

# Update the layout
fig.update_layout(
    polar=dict(
        radialaxis=dict(
            visible=True,
            range=[0, age_group_crime_means[crime_cols].values.max()] # Set range based on max crime score
        )),
    showlegend=True,
    title='Interactive Radar Chart: Average Crime Scores by Age Group and Crime Type'
)

# Show the plot
fig.show()

"""**Age Group 0 (30-35):** This group generally shows the lowest average crime scores across all crime types compared to the other age groups. The polygon is the smallest and closest to the center. Property crime appears to be relatively higher than other crime types within this group.

**Age Group 1 (35-38):** This group shows significantly higher average scores for violent and property crimes compared to Age Group 0. White-collar and social crime scores are also higher but to a lesser extent. The polygon is larger than Age Group 0, particularly extending on the violent and property crime axes.

**Age Group 2 (38-41):** This group tends to have the highest average scores for violent and property crimes. White-collar and social crime scores are also relatively high. The polygon for this group is the largest, especially on the violent and property crime axes.

**Age Group 3 (41+):** This group shows moderate to high average scores for violent and property crimes, but the scores are generally lower than Age Group 2. White-collar and social crime scores are lower compared to Age Group 1 and 2. The polygon is smaller than Age Group 2 but larger than Age Group 0, with a shape that is less extended on the white-collar and social crime axes.
In summary, the radar chart suggests that:

Crime rates, particularly violent and property crimes, tend to be higher in the older age groups (35-41 and 41+) compared to the youngest group (30-35).
Age Group 2 (38-41) appears to have the highest overall average crime scores across most categories.
White-collar and social crimes show a somewhat different pattern compared to violent and property crimes across the age groups.
This interpretation is based on the average values plotted in the radar chart. Keep in mind that these are averages, and there might be variation within each age group.
"""



import plotly.express as px
import pandas as pd

# Select education and crime score columns
education_cols = ['high_school_below', 'high_school', 'some_college', 'bachelors_degree']
crime_cols = ['violent_crime', 'property_crime', 'whitecollar_crime', 'social_crime']

# Melt the DataFrame to a long format for plotting
# We need to melt both the education columns and the crime columns
# This requires a slightly more complex melt or reshaping.

# Let's first melt the crime columns
crime_melted = df_uber_cleaned.melt(value_vars=crime_cols, var_name='Crime Type', value_name='Crime Score', id_vars=education_cols)

# Now, melt the education columns within the crime melted data
# This will create pairs of (Education Type, Education Percentage) for each row
education_crime_melted = crime_melted.melt(id_vars=['Crime Type', 'Crime Score'],
                                            value_vars=education_cols,
                                            var_name='Education Level',
                                            value_name='Education Percentage')


# Create the interactive grouped violin plot using Plotly Express
fig_violin = px.violin(
    education_crime_melted,
    x='Education Level',
    y='Crime Score',
    color='Crime Type',
    box=True, # Add box plot inside the violin
    points="all", # Show all points
    hover_data=['Crime Type', 'Crime Score', 'Education Level', 'Education Percentage'],
    title='Interactive Distribution of Crime Scores by Education Level and Crime Type',
    labels={'Education Level': 'Education Level', 'Crime Score': 'Crime Score'}
)
fig_violin.update_layout(xaxis_title='Education Level', yaxis_title='Crime Score')
fig_violin.show()

"""This plot uses violin shapes to represent the distribution of crime scores for each combination of education level category and crime type.

**Education Levels (X-axis):** The x-axis represents the different education level categories: 'high_school_below', 'high_school', 'some_college', and 'bachelors_degree'. Keep in mind these are based on percentages in the dataset.

**Crime Score (Y-axis):** The y-axis represents the range of crime scores for each crime type.

**Crime Type (Hue): **The different colors represent the four crime types: 'violent_crime', 'property_crime', 'whitecollar_crime', and 'social_crime'.

**Violin Shapes**: The width of each violin shape at a particular crime score level indicates the density or frequency of cities with that crime score and education level. A wider section means more cities have crime scores in that range.
**Split Violins:** The split=True parameter helps compare the distributions of two different crime types within the same education level category more easily by splitting the violin. However, with four crime types and no clear pair to split, the effect might be less pronounced than in a simple two-category comparison.
**Inner Quartiles:** The lines inside the violin represent the quartiles (25th, 50th - median, and 75th percentiles) of the distribution. The central line is the median.
By examining the plot, you can observe:

**How crime scores are distributed:** See if the crime scores are concentrated in a narrow range or spread out for a given education level and crime type.
Differences in distributions: Compare the shapes and positions of the violins to see how the distributions of crime scores differ across education levels for a specific crime type, or across crime types for a specific education level. For example, you can see if the median property crime score is higher for cities with a higher percentage of people with only a high school education compared to those with a bachelor's degree.
**Presence of outliers:** While not explicitly marked, the tails of the violin shapes can suggest the presence of outliers or extreme values in the distribution.
Overall, this violin plot is useful for understanding the nuances of how crime scores are distributed in relation to different education levels and crime types, going beyond just simple averages.
"""

